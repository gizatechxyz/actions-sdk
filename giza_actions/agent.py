import os
import time
from web3 import Web3
from eth_account import Account
from eth_account.messages import SignableMessage
from eth_typing import Address
from giza_actions.model import GizaModel
import requests
import logging
from giza.frameworks.cairo import verify
from giza_actions.utils import get_deployment_uri
from giza.client import DeploymentsClient
from giza import API_HOST
from pydantic import BaseModel
from dotenv import load_dotenv
from typing import List, Optional, Union

load_dotenv()

class ProofType(BaseModel):
    model_id: int # The model being used for inference
    proof: Optional[str] # The proof of inference
    address: Address # Who is the signer?
    
class ProofMessage(BaseModel):
    proof: ProofType
    
class GizaAgent(GizaModel):
    """
    A blockchain AI agent that helps users put their Actions on-chain. Uses Ape framework and GizaModel to verify a model proof off-chain, sign it with the user's account, and send results to a select EVM chain to execute code.

    Attributes:
        model (GizaModel): The model that this deployer uploads proofs for. This model must have the following fields: id, version, orion_runner_service_url in order to work. This is because all on-chain models require a proof to be generated by Orion Runner.
        inference: The result of the GizaModel inference
        request_id: The request_id of the proof to fetch from the GCP
        proof: The proof from GCP that we will use to verify, sign, and send along with inference data
        

    Methods:
        infer: Runs model inference and retrieves the model output
        get_model_data: retrieves the proof from GCP given the request_id, version_id, deployment_id, and internal model_id
        generate_calldate: generates calldata for a given smart contract function
        verify: verifies the proof locally
        deploy: verifies the proof, then calls the smart contract with calldata from inference
    """
    
    def __init__(self, id: Optional[int] = None, version: Optional[int] = None, **kwargs):
        """Initialize deployer.
        
        Args:
            model (GizaModel): GizaModel instance
        """
        super().__init__(id=id, version=version, **kwargs)

    def infer(self, input_file=None, input_feed=None):

        params = {}
        
        if input_file is not None:
            params['input_file'] = input_file
            
        if input_feed is not None:
            params['input_feed'] = input_feed

        params['verifiable'] = True
        params['job_size'] = "M"
        params['output_dtype'] = "Tensor<FP16x16>"
        
        self.inference, self.request_id = self.predict(**params)

        print("Inference saved! ‚úÖ Result: ", self.inference, self.request_id)
        
    def get_model_data(self):
        """Get proof data from GCP and save it as a class attribute"""
        client = DeploymentsClient(API_HOST)

        uri = get_deployment_uri(self.model_id, self.version_id)
        # get this from CLI
        proof_metadata_url = f"https://api.gizatech.xyz/api/v1/models/{self.model_id}/versions/{self.version_id}/deployments/{uri}/proofs/{self.request_id}:download"

        time.sleep(3)
        logging.info(f"Fetching proof metadata from {proof_metadata_url}... ‚è≥")
        deployment_id = get_deployment_id(self.model_id, self.version_id)
        timeout = time.time() + 800

        while True:
            now = time.time()
            if now > timeout:
                print("Proof retrieval timed out")
                raise TimeoutError("Proof retrieval timed out")
            try:
                proof = client.get_proof(self.model_id, self.version_id, deployment_id, self.request_id)
                print(f"Proof: {proof.json(exclude_unset=True)}")
                break  # Exit the loop if proof is retrieved successfully
            except requests.exceptions.HTTPError:
                print("Proof retrieval failing, sleeping for 5 seconds")
                time.sleep(5)

        # Save the proof to a file
        proof_file = "zk.proof"
        content = client.download_proof(self.model_id, self.version_id, deployment_id, self.request_id)
        with open(proof_file, "wb") as f:
            f.write(content)

        return os.path.abspath(proof_file)
                
    def _generate_calldata(self, contract_address: Address, chain_id, function_name, parameters):
        """
        Generate calldata for calling a smart contract function

        Args:
            abi_path (str): Path to JSON ABI for the contract
            function_name (str): Name of contract function to call 
            parameters (list): Arguments to pass to the function

        Returns:
            str: Hex string of calldata
        """
        
        web3 = Web3()

        # TODO: Add support for other chains
        if chain_id == 1:
            # Ethereum Mainnet
            etherscan_url = "https://api.etherscan.io/api"
        elif chain_id == 1115511:
            # Ethereum Sepolia Testnet
            etherscan_url = "https://api-sepolia.etherscan.io/api"
        elif chain_id == 5:
            # Ethereum Goerli Testnet
            etherscan_url = "https://api-goerli.etherscan.io/api"
        else:
            raise ValueError("Unsupported chain ID")
        
        # Make an API request to the Etherscan API to retrieve the contract ABI
        params = {
            "module": "contract",
            "action": "getabi",
            "address": contract_address,
            "apikey": os.environ["ETHERSCAN_API_KEY"],
        }
        
        response = requests.get(etherscan_url, params=params)
        response_json = response.json()
        
        if response_json["status"] == "1":
            abi = response_json["result"][0]["ABI"]
        else:
            raise ValueError("Failed to retrieve contract ABI")
        
        contract = web3.eth.contract(abi=abi)
        
        function_abi = None
        for item in abi:
            if 'name' in item and item['name'] == function_name:
                function_abi = item
                break
        
        if function_abi is None:
            raise ValueError(f"Function {function_name} not found in ABI")
        
        calldata = contract.encodeABI(function_name, args=parameters)
        return calldata
    
    async def sign_proof(self, account: Account, proof: Optional[str]):
        address = account.address
        
        proof = ProofType(model_id=self.model_id, proof=proof, address=address)
        proofMessage = ProofMessage(proof=proof)
        
        raw_message = proofMessage.proof.proof
        version = b'\x19'
        header = b''
        
        if proofMessage.proof.proof is None:
            dummy_message = "dummy_proof"
            dummy_body = dummy_message.encode('utf-8')
            dummy_signable_message = SignableMessage(version=version, header=header, body=dummy_body)
            dummy_signature = account.sign_message(dummy_signable_message)
            return (dummy_signature, True, proofMessage)
        
        body = raw_message.encode('utf-8')
        signable_message = SignableMessage(version=version, header=header, body=body)
        sig = account.sign_message(signable_message)
        return (sig, False, proofMessage)
        
    async def verify(self, proof):
        """
        Verify proof locally. Must be run *after* infer() and _get_model_data() have been run.
        
        Returns:
            bool: True if proof is valid
        """
        model_id = self.model_id
        version_id = self.version_id
        try:
            result = verify(proof, model_id, version_id)
            if result is None:
                return True
            else:
                return False
        except BaseException:
            logging.error("An error occurred when verifying")
            return False
        
    def transmit(self, account: Account, contract_address: Address, chain_id: int, function_name: str, params, signed_proof, is_none, proofMessage, rpc_url: Optional[str], unsafe: bool = False):
        """
        Transmit: Verify the proof signature (so we know that the account owner signed off on the proof verification), verify the proof, then send the transaction to the contract.
        
        Returns:
            A transaction receipt
        """    
        
        web3 = Web3()
        
        if not unsafe:
            if is_none:
                raise ValueError("Proof cannot be None when unsafe is False")
            
            print("Proof retrieved! ‚úÖ")
            signer = web3.eth.account.recover_message(proofMessage.proof.proof, signed_proof)
            assert signer.lower() == account.address.lower()
            print("Proof signature verified! üî•")
            assert self._verify(proofMessage.proof.proof)
            print("Proof verified! ‚ö°Ô∏è")
        else:
            if is_none:
                print("Warning: Proof is None. Skipping proof verification.")
                # Generate a dummy signature
                signed_proof = account.sign_message("dummy_proof")
            else:
                print("Proof retrieved! ‚úÖ")
                signer = web3.eth.account.recover_message(proofMessage.proof.proof, signed_proof)
                assert signer.lower() == account.address.lower()
                print("Proof signature verified! üî•")
                assert self._verify(proofMessage.proof.proof)
                print("Proof verified! ‚ö°Ô∏è")
        
        print("All good! ‚úÖ Sending transaction...")
        
        try:
            if rpc_url is not None:
                web3 = Web3(Web3.HTTPProvider(rpc_url))
            else:
                alchemy_url = "https://eth-sepolia.g.alchemy.com/v2/aGP6ImVTfOlef4kzUxw0-31sabFgyTCT"
                web3 = Web3(Web3.HTTPProvider(alchemy_url))
            # contract = web3.eth.contract(address=contract_address, abi=contract_abi)
            nonce = web3.eth.get_transaction_count(account.address)  
            
            calldata = self._generate_calldata(contract_address, chain_id, function_name, params)

            #TODO: Figure out how to estimate gas
            transaction = {
                "to": contract_address, 
                "data": calldata,
                "nonce": nonce,
                "gas": 200000,
                "gasPrice": 40000000000,
            }

            signed_tx = account.sign_transaction(transaction)
            tx_hash = web3.eth.send_raw_transaction(signed_tx.rawTransaction)  
            receipt = web3.eth.wait_for_transaction_receipt(tx_hash)
            return receipt
        
        except ValueError as e:
            print(f"Error encoding transaction: {e}")
            return None

        except Exception as e:
            print(f"Error transmitting transaction: {e}")
            return None

        
        
def get_deployment_id(model_id, version_id):
    """
    Retrieve the deployment ID for the model and version.

    Returns:
        int: The ID of the deployment.
    """
    client = DeploymentsClient(API_HOST)
    return client.list(model_id, version_id).root[0].id